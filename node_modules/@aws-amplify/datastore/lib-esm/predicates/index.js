import { __assign, __read, __spread } from "tslib";
import { extractPrimaryKeyFieldNames, extractPrimaryKeyValues } from '../util';
export { ModelSortPredicateCreator } from './sort';
var predicatesAllSet = new WeakSet();
export function isPredicatesAll(predicate) {
    return predicatesAllSet.has(predicate);
}
/**
 * The valid logical grouping keys for a predicate group.
 */
var groupKeys = new Set(['and', 'or', 'not']);
/**
 * Determines whether an object is a GraphQL style predicate "group", which must be an
 * object containing a single "group key", which then contains the child condition(s).
 *
 * E.g.,
 *
 * ```
 * { and: [ ... ] }
 * { not: { ... } }
 * ```
 *
 * @param o The object to test.
 */
var isGroup = function (o) {
    var keys = __spread(Object.keys(o));
    return keys.length === 1 && groupKeys.has(keys[0]);
};
/**
 * The valid comparison operators that can be used as keys in a predicate comparison object.
 */
export var comparisonKeys = new Set([
    'eq',
    'ne',
    'gt',
    'lt',
    'ge',
    'le',
    'contains',
    'notContains',
    'beginsWith',
    'between',
]);
/**
 * Determines whether an object is a GraphQL style predicate comparison node, which must
 * be an object containing a single "comparison operator" key, which then contains the
 * operand or operands to compare against.
 *
 * @param o The object to test.
 */
var isComparison = function (o) {
    var keys = __spread(Object.keys(o));
    return !Array.isArray(o) && keys.length === 1 && comparisonKeys.has(keys[0]);
};
var isComparisonArray = function (o) {
    return Array.isArray(o) && isComparison(o[0]);
};
/**
 * A light check to determine whether an object is a valid GraphQL Condition AST.
 *
 * @param o The object to test.
 */
var isValid = function (o) {
    if (Array.isArray(o)) {
        return o.every(function (v) { return isValid(v); });
    }
    else {
        return Object.keys(o).length === 1;
    }
};
// This symbol is not used at runtime, only its type (unique symbol)
export var PredicateAll = Symbol('A predicate that matches all records');
var Predicates = /** @class */ (function () {
    function Predicates() {
    }
    Object.defineProperty(Predicates, "ALL", {
        get: function () {
            var predicate = (function (c) { return c; });
            predicatesAllSet.add(predicate);
            return predicate;
        },
        enumerable: true,
        configurable: true
    });
    return Predicates;
}());
export { Predicates };
var ModelPredicateCreator = /** @class */ (function () {
    function ModelPredicateCreator() {
    }
    ModelPredicateCreator.createPredicateBuilder = function (modelDefinition) {
        var modelName = modelDefinition.name;
        var fieldNames = new Set(Object.keys(modelDefinition.fields));
        var handler;
        var predicate = new Proxy({}, (handler = {
            get: function (_, propertyKey, self) {
                var groupType = propertyKey;
                switch (groupType) {
                    case 'and':
                    case 'or':
                    case 'not':
                        var result_1 = function (newPredicate) {
                            var group = {
                                type: groupType,
                                predicates: [],
                            };
                            // Create a new recorder
                            var tmpPredicateRecorder = new Proxy({}, handler);
                            // Set the recorder group
                            ModelPredicateCreator.predicateGroupsMap.set(tmpPredicateRecorder, group);
                            // Apply the predicates to the recorder (this is the step that records the changes)
                            newPredicate(tmpPredicateRecorder);
                            // Push the group to the top-level recorder
                            ModelPredicateCreator.predicateGroupsMap
                                .get(self)
                                .predicates.push(group);
                            return self;
                        };
                        return result_1;
                    default:
                    // intentionally blank.
                }
                var field = propertyKey;
                if (!fieldNames.has(field)) {
                    throw new Error("Invalid field for model. field: " + field + ", model: " + modelName);
                }
                var result = function (operator, operand) {
                    ModelPredicateCreator.predicateGroupsMap
                        .get(self)
                        .predicates.push({ field: field, operator: operator, operand: operand });
                    return self;
                };
                return result;
            },
        }));
        var group = {
            type: 'and',
            predicates: [],
        };
        ModelPredicateCreator.predicateGroupsMap.set(predicate, group);
        return predicate;
    };
    ModelPredicateCreator.isValidPredicate = function (predicate) {
        return ModelPredicateCreator.predicateGroupsMap.has(predicate);
    };
    ModelPredicateCreator.getPredicates = function (predicate, throwOnInvalid) {
        if (throwOnInvalid === void 0) { throwOnInvalid = true; }
        if (throwOnInvalid && !ModelPredicateCreator.isValidPredicate(predicate)) {
            throw new Error('The predicate is not valid');
        }
        return ModelPredicateCreator.predicateGroupsMap.get(predicate);
    };
    // transforms cb-style predicate into Proxy
    ModelPredicateCreator.createFromExisting = function (modelDefinition, existing) {
        if (!existing || !modelDefinition) {
            return undefined;
        }
        return existing(ModelPredicateCreator.createPredicateBuilder(modelDefinition));
    };
    ModelPredicateCreator.createForSingleField = function (modelDefinition, fieldName, value) {
        return ModelPredicateCreator.createPredicateBuilder(modelDefinition)[fieldName]('eq', value);
    };
    ModelPredicateCreator.createForPk = function (modelDefinition, model) {
        var keyFields = extractPrimaryKeyFieldNames(modelDefinition);
        var keyValues = extractPrimaryKeyValues(model, keyFields);
        var modelPredicate = ModelPredicateCreator.createPredicateBuilder(modelDefinition);
        keyFields.forEach(function (field, idx) {
            var operand = keyValues[idx];
            modelPredicate = modelPredicate[field]('eq', operand);
        });
        return modelPredicate;
    };
    /**
     * Searches a `Model` table for records matching the given equalities object.
     *
     * This only matches against fields given in the equalities object. No other
     * fields are tested by the predicate.
     *
     * @param modelDefinition The model we need a predicate for.
     * @param flatEqualities An object holding field equalities to search for.
     */
    ModelPredicateCreator.createFromFlatEqualities = function (modelDefinition, flatEqualities) {
        var ast = {
            and: Object.entries(flatEqualities).map(function (_a) {
                var _b;
                var _c = __read(_a, 2), k = _c[0], v = _c[1];
                return (_b = {}, _b[k] = { eq: v }, _b);
            }),
        };
        return this.createFromAST(modelDefinition, ast);
    };
    /**
     * Accepts a GraphQL style filter predicate tree and transforms it into an
     * AST that can be used for a storage adapter predicate. Example input:
     *
     * ```js
     * {
     * 	and: [
     * 		{ name: { eq: "Bob Jones" } },
     * 		{ age: { between: [32, 64] } },
     * 		{ not: {
     * 			or: [
     * 				{ favoriteFood: { eq: 'pizza' } },
     * 				{ favoriteFood: { eq: 'tacos' } },
     * 			]
     * 		}}
     * 	]
     * }
     * ```
     *
     * @param gql GraphQL style filter node.
     */
    ModelPredicateCreator.transformGraphQLFilterNodeToPredicateAST = function (gql) {
        var _this = this;
        if (!isValid(gql)) {
            throw new Error('Invalid GraphQL Condition or subtree: ' + gql);
        }
        if (isGroup(gql)) {
            var groupkey = Object.keys(gql)[0];
            var children = this.transformGraphQLFilterNodeToPredicateAST(gql[groupkey]);
            return {
                type: groupkey,
                predicates: Array.isArray(children) ? children : [children],
            };
        }
        else if (isComparison(gql)) {
            var operatorKey = Object.keys(gql)[0];
            return {
                operator: operatorKey,
                operand: gql[operatorKey],
            };
        }
        else {
            if (Array.isArray(gql)) {
                return gql.map(function (o) { return _this.transformGraphQLFilterNodeToPredicateAST(o); });
            }
            else {
                var fieldKey = Object.keys(gql)[0];
                return __assign({ field: fieldKey }, this.transformGraphQLFilterNodeToPredicateAST(gql[fieldKey]));
            }
        }
    };
    /**
     * Accepts a GraphQL style filter predicate tree and transforms it into a predicate
     * that storage adapters understand. Example input:
     *
     * ```js
     * {
     * 	and: [
     * 		{ name: { eq: "Bob Jones" } },
     * 		{ age: { between: [32, 64] } },
     * 		{ not: {
     * 			or: [
     * 				{ favoriteFood: { eq: 'pizza' } },
     * 				{ favoriteFood: { eq: 'tacos' } },
     * 			]
     * 		}}
     * 	]
     * }
     * ```
     *
     * @param modelDefinition The model that the AST/predicate must be compatible with.
     * @param ast The graphQL style AST that should specify conditions for `modelDefinition`.
     */
    ModelPredicateCreator.createFromAST = function (modelDefinition, ast) {
        var predicate = ModelPredicateCreator.createPredicateBuilder(modelDefinition);
        ModelPredicateCreator.predicateGroupsMap.set(predicate, this.transformGraphQLFilterNodeToPredicateAST(ast));
        return predicate;
    };
    ModelPredicateCreator.predicateGroupsMap = new WeakMap();
    return ModelPredicateCreator;
}());
export { ModelPredicateCreator };
//# sourceMappingURL=index.js.map